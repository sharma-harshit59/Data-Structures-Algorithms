SOLUTION:
The problem is to count the number of contiguous subarrays whose sum equals k.
We can solve this efficiently using the Prefix Sum + HashMap approach in O(n) time.

1)  Initialize Data Structures
    - Use a hash map `prefixSum` to store:
        key   → a prefix sum value
        value → how many times this prefix sum has occurred so far
    - Initialize with {0: 1} to handle cases where the subarray starts from index 0.

2)  Maintain Running Sum
    - Iterate through the array, keeping a running sum `sum`.
    - At each step, the number of subarrays ending at the current index with sum k is exactly:
        prefixSum[sum - k]
      because:
        sum(i, j) = prefix[j] - prefix[i-1] = k
        ⇒ prefix[i-1] = prefix[j] - k

3)  Count Matching Prefix Sums
    - If (sum - k) exists in `prefixSum`, increment `count` by its stored frequency.
    - This accounts for all subarrays ending at the current index whose sum is k.

4)  Update Hash Map
    - Increment the frequency of the current `sum` in `prefixSum` for future matches.

5)  Return the Count
    - After processing all elements, `count` will be the total number of subarrays with sum = k.

TIME-COMPLEXITY: O(n) — Each element is processed once, hash map operations are O(1) on average.  
SPACE-COMPLEXITY: O(n) — In the worst case, all prefix sums are unique and stored in the map.