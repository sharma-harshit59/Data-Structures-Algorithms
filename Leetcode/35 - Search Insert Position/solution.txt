SOLUTION:  
This problem is a variation of Binary Search.  
Instead of only checking whether a target exists, you're also required to determine the index where it should be inserted in order to maintain the sorted order.

Since the input array is sorted and contains distinct values, Binary Search is ideal — enabling an efficient O(log n) runtime.

1) Initialize the Search Range  
   Define two pointers to represent the current search bounds:
       - `firstIdx` starting at the beginning of the array.
       - `lastIdx` at the end of the array.
   Also define `midIdx` to track the midpoint of the current search range, which is recalculated each iteration.

2) Binary Search Loop  
   While the search space is valid (i.e., `firstIdx <= lastIdx`):
       - Compute `midIdx` as the average of `firstIdx` and `lastIdx`.
       - Compare the middle element (`nums[midIdx]`) with the target:
           a) If equal, return `midIdx` — the target is found.
           b) If the target is greater, discard the left half including `midIdx` by setting `firstIdx = midIdx + 1`.
           c) If the target is smaller, discard the right half by setting `lastIdx = midIdx - 1`.

   The loop ends when `firstIdx > lastIdx`, meaning the target isn't found and must be inserted at the correct position.

3) Why the Final midIdx Determines Insertion Point  
   Once the loop terminates:
       - The last `midIdx` is the midpoint of the final narrowed subrange.
       - If `nums[midIdx] < target`, the correct insertion point is just after `midIdx` → `midIdx + 1`.
       - Otherwise, the correct insertion point is exactly at `midIdx`.

   This approach guarantees the correct position for the target, preserving the sorted property of the array.

TIME-COMPLEXITY: O(log n) — each loop iteration halves the search space.
SPACE-COMPLEXITY: O(1) — only three integer variables are used.