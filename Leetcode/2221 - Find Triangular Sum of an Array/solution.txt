NAIVE SOLUTION:  
To compute the triangular sum of an array, we repeatedly reduce the array by summing adjacent elements modulo 10 until a single element remains.
Key idea:  
- At each step, we generate a new array where each element is `(nums[i] + nums[i-1]) % 10`.
- Replace the original array with this new array and continue until only one element remains.

STEPS:
1) Initialize:
   - Input array `nums`.

2) While `nums.length > 1`:
   - Create a temporary array `temp`.
   - For each i from 1 to nums.length - 1:
     - Compute `(nums[i] + nums[i-1]) % 10` and push it to temp.
   - Replace nums with temp.

3) Return nums[0] as the final triangular sum.

TIME-COMPLEXITY: O(n²)
SPACE-COMPLEXITY: O(n²) (for the temporary array)

---------------------------------------------------------------------------------------------------

BETTER SOLUTION:  
Instead of creating a new array every time, we compute the sums in-place, reducing memory overhead.
Key idea:  
- Modify the array directly: `nums[i-1] = (nums[i-1] + nums[i]) % 10`.  
- After each pass, the last element can be ignored since it’s no longer needed.

STEPS:
1) Initialize:
   - n = nums.length

2) While n > 1:
   - For i from 1 to nums.length - 1:
     - nums[i-1] = (nums[i-1] + nums[i]) % 10
   - Decrease n by 1

3) Return nums[0] as the triangular sum.

TIME-COMPLEXITY: O(n²)  
SPACE-COMPLEXITY: O(1)

---------------------------------------------------------------------------------------------------

BEST SOLUTION:  
Compute the triangular sum directly using combinatorics: the final number is the sum of nums[i] * C(n-1, i) modulo 10.
Key idea:  
- Triangular sum = sum of nums[i] * C(n-1, i) % 10  
- Compute C(n-1, i) iteratively: C(n, i) = C(n, i-1) * (n-i)/i  
- Use BigInt in JS/TS to avoid overflow.

STEPS:
1) Initialize:
   - res = 0, C = 1 (first binomial coefficient)

2) For i from 0 to n-1:
   - res = (res + (C % 10) * nums[i] % 10) % 10
   - C = C * (n-1-i) / (i+1)

3) Return res as the triangular sum.

TIME-COMPLEXITY: O(n)  
SPACE-COMPLEXITY: O(1)
