SOLUTION:  
This problem is a classic use case for a Hash Map (or Dictionary) to achieve constant-time lookups.  
You are given an array of integers `nums` and an integer `target`. The task is to return the indices of two distinct numbers that sum to the target.

1) Use a Hash Map to Store Seen Numbers and Their Indices  
   - Iterate through the array once.  
   - For each number, compute its complement: `target - nums[i]`.  
   - Check if that complement exists in the hash map.  
   - If it exists, return the indices `[hashMap[complement], i]`.  

2) Build the Hash Map While Iterating  
   - If the complement is not found, store the current number in the hash map with its index as the value.  
   - This ensures that any future number can quickly find its matching complement from the past in O(1) time.  

3) Why This Works Efficiently and Correctly  
   - The problem guarantees exactly one valid pair, so as soon as we find it, we can return immediately without extra work.  
   - Each number is processed only once, and the hash map provides constant-time lookups.  
   - Storing elements as we go avoids the need for nested loops, which would increase complexity to O(n²).

TIME-COMPLEXITY: O(n) — One pass through the array, with O(1) average lookup and insert time for the hash map.  
SPACE-COMPLEXITY: O(n) — In the worst case, the hash map stores all `n` elements.